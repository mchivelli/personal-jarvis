<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streaming Voice Assistant</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            font-size: 36px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .status-bar {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ccc;
        }

        .status-dot.connected {
            background: #4caf50;
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
        }

        .mic-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 40px 0;
        }

        .mic-button {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 60px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            position: relative;
        }

        .mic-button:hover:not(.disabled) {
            transform: scale(1.05);
        }

        .mic-button.recording {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            animation: pulse-red 1s infinite;
        }

        .mic-button.processing {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            animation: rotate 2s linear infinite;
        }

        .mic-button.disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        @keyframes pulse-red {
            0%, 100% { transform: scale(1); box-shadow: 0 10px 30px rgba(245, 87, 108, 0.4); }
            50% { transform: scale(1.05); box-shadow: 0 10px 50px rgba(245, 87, 108, 0.8); }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .interrupt-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #f44336;
            background: white;
            color: #f44336;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: none;
        }

        .interrupt-button.show {
            display: block;
        }

        .interrupt-button:hover {
            background: #f44336;
            color: white;
        }

        .conversation {
            background: #f8f9fa;
            border-radius: 20px;
            padding: 25px;
            min-height: 450px;
            max-height: 500px;
            overflow-y: auto;
            margin: 20px 0;
            scroll-behavior: smooth;
        }

        .message {
            margin: 15px 0;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 75%;
            line-height: 1.6;
            animation: slideIn 0.3s ease;
            word-wrap: break-word;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .message.assistant {
            background: white;
            color: #333;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .message.streaming {
            border-left: 3px solid #667eea;
            padding-left: 17px;
        }

        .message .timestamp {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 8px;
            font-style: italic;
        }

        .message.assistant .typing-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
            animation: blink 1.4s infinite;
            margin-left: 3px;
        }

        .message.confirmation {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            color: white;
            border: 2px solid #f39c12;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
        }

        .confirmation-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .confirm-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .confirm-btn.yes {
            background: #27ae60;
            color: white;
        }

        .confirm-btn.yes:hover {
            background: #229954;
        }

        .confirm-btn.no {
            background: #e74c3c;
            color: white;
        }

        .confirm-btn.no:hover {
            background: #c0392b;
        }

        @keyframes blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric {
            background: white;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .metric-label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            font-size: 14px;
            color: #666;
        }

        .intent-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            margin-top: 5px;
        }

        .intent-badge.conversation {
            background: #e3f2fd;
            color: #1976d2;
        }

        .intent-badge.tools {
            background: #fff3e0;
            color: #f57c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Streaming Voice Assistant</h1>
        <p class="subtitle">Real-time conversation with interrupt capability</p>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionDot"></div>
                <span id="connectionStatus">Connecting...</span>
            </div>
            <div class="status-message" id="statusMessage">Initializing...</div>
        </div>

        <div class="metrics">
            <div class="metric">
                <div class="metric-value" id="latency">0ms</div>
                <div class="metric-label">Latency</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="messageCount">0</div>
                <div class="metric-label">Messages</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="currentIntent">-</div>
                <div class="metric-label">Mode</div>
            </div>
        </div>

        <div class="mic-container">
            <button class="interrupt-button" id="interruptBtn" onclick="interruptResponse()">
                STOP
            </button>
            <button class="mic-button" id="micButton" onclick="toggleRecording()">
                üé§
            </button>
        </div>

        <div class="conversation" id="conversation"></div>

        <div class="controls">
            <button class="btn secondary" onclick="clearConversation()">Clear Chat</button>
            <button class="btn primary" onclick="testConnection()">Test Connection</button>
        </div>
    </div>

    <script>
        let socket;
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let isProcessing = false;
        let startTime;
        let messageCount = 0;
        let currentStreamingMessage = null;

        const micButton = document.getElementById('micButton');
        const interruptBtn = document.getElementById('interruptBtn');
        const conversation = document.getElementById('conversation');
        const statusMessage = document.getElementById('statusMessage');
        const connectionStatus = document.getElementById('connectionStatus');
        const connectionDot = document.getElementById('connectionDot');
        const latencyEl = document.getElementById('latency');
        const messageCountEl = document.getElementById('messageCount');
        const currentIntentEl = document.getElementById('currentIntent');

        // Initialize WebSocket connection
        function connectWebSocket() {
            socket = io('http://localhost:5002');

            socket.on('connect', () => {
                console.log('Connected to server');
                connectionStatus.textContent = 'Connected';
                connectionDot.classList.add('connected');
                statusMessage.textContent = 'Ready! Press and hold to talk';
                micButton.classList.remove('disabled');
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from server');
                connectionStatus.textContent = 'Disconnected';
                connectionDot.classList.remove('connected');
                statusMessage.textContent = 'Connection lost...';
                micButton.classList.add('disabled');
            });

            socket.on('status', (data) => {
                statusMessage.textContent = data.message;
            });

            socket.on('transcript', (data) => {
                addMessage('user', data.text);
                const latency = Date.now() - startTime;
                latencyEl.textContent = `${latency}ms`;
            });

            socket.on('intent', (data) => {
                currentIntentEl.textContent = data.intent;
            });

            socket.on('response_chunk', (data) => {
                if (!currentStreamingMessage) {
                    currentStreamingMessage = createStreamingMessage();
                }
                
                appendToStreamingMessage(data.chunk);
                
                if (data.done) {
                    finalizeStreamingMessage();
                }
            });

            socket.on('confirmation_request', (data) => {
                // Show confirmation message with special styling
                addConfirmationMessage(data.text, data.tools);
                isProcessing = false;
                micButton.classList.remove('processing');
                micButton.textContent = 'üé§';
                statusMessage.textContent = 'Say "yes" to confirm or "no" to cancel';
            });

            socket.on('response_complete', (data) => {
                addMessage('assistant', data.text);
                isProcessing = false;
                interruptBtn.classList.remove('show');
                micButton.classList.remove('processing');
                statusMessage.textContent = 'Ready! Press and hold to talk';
            });

            socket.on('response_interrupted', () => {
                if (currentStreamingMessage) {
                    finalizeStreamingMessage();
                }
                isProcessing = false;
                interruptBtn.classList.remove('show');
                micButton.classList.remove('processing');
                statusMessage.textContent = 'Interrupted - Ready to talk';
            });

            socket.on('error', (data) => {
                statusMessage.textContent = `Error: ${data.message}`;
                isProcessing = false;
                micButton.classList.remove('processing');
            });
        }

        // Push-to-talk controls
        micButton.addEventListener('mousedown', startRecording);
        micButton.addEventListener('mouseup', stopRecording);
        micButton.addEventListener('touchstart', startRecording);
        micButton.addEventListener('touchend', stopRecording);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isRecording && !isProcessing) {
                e.preventDefault();
                startRecording();
            }
            if (e.code === 'Escape' && isProcessing) {
                interruptResponse();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && isRecording) {
                e.preventDefault();
                stopRecording();
            }
        });

        async function startRecording() {
            if (isRecording || isProcessing || !socket || !socket.connected) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus'
                    : 'audio/webm';

                mediaRecorder = new MediaRecorder(stream, { mimeType });
                audioChunks = [];
                startTime = Date.now();

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    await sendAudioToServer(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start(100);
                isRecording = true;
                micButton.classList.add('recording');
                micButton.textContent = 'üî¥';
                statusMessage.textContent = 'üé§ Recording... (release to send)';

            } catch (error) {
                console.error('Microphone error:', error);
                statusMessage.textContent = 'Error: Could not access microphone';
            }
        }

        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                isRecording = false;
                isProcessing = true;
                micButton.classList.remove('recording');
                micButton.classList.add('processing');
                micButton.textContent = '‚è≥';
                statusMessage.textContent = 'Processing...';
                interruptBtn.classList.add('show');
            }
        }

        async function sendAudioToServer(audioBlob) {
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = () => {
                const base64Audio = reader.result.split(',')[1];
                socket.emit('audio_data', { audio: base64Audio });
            };
        }

        function createStreamingMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant streaming';
            messageDiv.innerHTML = '<div class="content"></div><div class="typing-indicator"></div>';
            conversation.appendChild(messageDiv);
            conversation.scrollTop = conversation.scrollHeight;
            return messageDiv;
        }

        function appendToStreamingMessage(chunk) {
            if (currentStreamingMessage) {
                const contentDiv = currentStreamingMessage.querySelector('.content');
                contentDiv.textContent += chunk;
                conversation.scrollTop = conversation.scrollHeight;
            }
        }

        function finalizeStreamingMessage() {
            if (currentStreamingMessage) {
                const indicator = currentStreamingMessage.querySelector('.typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
                currentStreamingMessage.classList.remove('streaming');
                
                const timestamp = document.createElement('div');
                timestamp.className = 'timestamp';
                timestamp.textContent = new Date().toLocaleTimeString();
                currentStreamingMessage.appendChild(timestamp);
                
                currentStreamingMessage = null;
                messageCount++;
                messageCountEl.textContent = messageCount;
            }
            isProcessing = false;
            interruptBtn.classList.remove('show');
            micButton.classList.remove('processing');
            micButton.textContent = 'üé§';
            statusMessage.textContent = 'Ready! Press and hold to talk';
        }

        function addMessage(type, text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.textContent = text;
            
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timestamp);
            conversation.appendChild(messageDiv);
            conversation.scrollTop = conversation.scrollHeight;
            
            messageCount++;
            messageCountEl.textContent = messageCount;
        }

        function addConfirmationMessage(text, tools) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant confirmation';
            
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = `
                <strong>‚ö†Ô∏è Confirmation Required</strong><br>
                ${text}
            `;
            
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'confirmation-buttons';
            
            const yesBtn = document.createElement('button');
            yesBtn.className = 'confirm-btn yes';
            yesBtn.textContent = '‚úì Yes, Proceed';
            yesBtn.onclick = () => {
                // Remove buttons after click
                buttonsDiv.remove();
                statusMessage.textContent = 'Say "yes" or click microphone to confirm';
            };
            
            const noBtn = document.createElement('button');
            noBtn.className = 'confirm-btn no';
            noBtn.textContent = '‚úó No, Cancel';
            noBtn.onclick = () => {
                // Remove buttons and send cancel
                buttonsDiv.remove();
                socket.emit('audio_data', { 
                    audio: btoa('no')  // Send cancel signal
                });
                statusMessage.textContent = 'Cancelled';
            };
            
            buttonsDiv.appendChild(yesBtn);
            buttonsDiv.appendChild(noBtn);
            
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(buttonsDiv);
            messageDiv.appendChild(timestamp);
            conversation.appendChild(messageDiv);
            conversation.scrollTop = conversation.scrollHeight;
            
            messageCount++;
            messageCountEl.textContent = messageCount;
        }

        function interruptResponse() {
            if (isProcessing && socket && socket.connected) {
                socket.emit('interrupt');
                statusMessage.textContent = 'Interrupting...';
            }
        }

        function clearConversation() {
            conversation.innerHTML = '';
            messageCount = 0;
            messageCountEl.textContent = '0';
            currentStreamingMessage = null;
        }

        async function testConnection() {
            statusMessage.textContent = 'Testing connection...';
            try {
                const res = await fetch('/api/test');
                const data = await res.json();
                if (data.success) {
                    statusMessage.textContent = '‚úì Connection OK';
                } else {
                    statusMessage.textContent = '‚úó Connection failed';
                }
            } catch (error) {
                statusMessage.textContent = '‚úó Server not responding';
            }
            setTimeout(() => {
                statusMessage.textContent = 'Ready! Press and hold to talk';
            }, 2000);
        }

        // Initialize on load
        window.addEventListener('load', () => {
            connectWebSocket();
        });
    </script>
</body>
</html>
